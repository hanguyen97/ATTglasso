cov2cor(abs(Theta)),
method = "color",
tl.pos = "n",
title = title,
diag = FALSE,
is.corr = FALSE,
col = colorRampPalette(c("white", "black"))(256),
cl.pos = "n",
mar = c(0, 0, 2, 0)
)
}
# pdf(file = paste0("corrplot_AR1.pdf"), width = 8, height = 6)
par(mfrow = c(2, 3), mar = c(1, 1, 3, 1))
plot_corr_matrix(Theta, "Ground truth")
plot_corr_matrix(Theta.hat.att.glasso, "AutotuneGLASSO")
plot_corr_matrix(Theta.hat.huge.ebic, "eBIC")
plot_corr_matrix(Theta.hat.huge.ric, "RIC")
plot_corr_matrix(Theta.hat.huge.stars, "StARS")
plot_corr_matrix(Theta.hat.cv.loglik, "5-fold CV")
par(mfrow = c(1, 1))
# dev.off()
lower = -13
upper = 3
lambda.grid <- 2^seq(upper, lower, by = -0.1); l <- length(lambda.grid)
source("library_test.R")
lower = -13
upper = 3
lambda.grid <- 2^seq(upper, lower, by = -0.1); l <- length(lambda.grid)
# source("library_test.R")
library(glasso)
rmse.arr.glasso = bic.arr.glasso = aic.arr.glasso = array(NA, l)
auroc.arr.glasso = array(NA, l)
flag <- 0
for(i in 1:l){
# Estimate
lambda <- lambda.grid[i]
# print(paste("start of", i, "-th exp for", r,"-th rep, ", log2(lambda)))
Theta.hat.glasso <- glasso(s=cov(X),rho=lambda)$wi
if(any(is.na(Theta.hat.glasso))){
rmse.arr.glasso[i] = auroc.arr.glasso[i] = NA
} else {
rmse.arr.glasso[i]<- rel.diff(Theta.hat.glasso, Theta)
}
i.best <- 0
if(i==1){
Theta.hat.best <- Theta.hat.glasso
start.rmse <- rmse.arr.glasso[i]
min.rmse <- NULL
i.best <- i
}
if(!is.na(rmse.arr.glasso[i])){
# now.bic <- bic.arr.glasso[i]
now.rmse <- rmse.arr.glasso[i]
min.rmse <- min(min.rmse, now.rmse)
if(min.rmse >= now.rmse){
i.best <- i
Theta.hat.best <- Theta.hat.glasso
}
if(now.rmse > min.rmse && now.rmse - min.rmse >= 0.4 * (start.rmse - min.rmse))
flag <- 1
}
if(flag == 1)
break
# print(paste("end of", i, "-th exp for", r,"-th rep,", log2(lambda)))
}
temp <- data.frame(rmse.arr.glasso)
plot(log2(lambda.grid), rmse.arr.glasso, type="l",
xlab="log2(lambda)", ylab="RMSE",
xlim = range(log2(lambda.grid)),     # or use c(min, max)
ylim = range(rmse.arr.glasso))
rmse.att.glasso <- rel.diff(Theta.hat.att.glasso, Theta)
abline(h = rmse.att.glasso, col = "blue", lwd = 2, lty = 2)
rmse.huge.stars <- rel.diff(Theta.hat.huge.stars, Theta)
points(log2(out.huge.stars$opt.lambda), rmse.huge.stars, col="red", pch=19)
rmse.huge.ric <- rel.diff(Theta.hat.huge.ric, Theta)
points(log2(out.huge.ric$opt.lambda), rmse.huge.ric, col="green", pch=19)
rmse.huge.ebic <- rel.diff(Theta.hat.huge.ebic, Theta)
points(log2(out.huge.ebic$opt.lambda), rmse.huge.ebic, col="purple", pch=19)
rmse.cv.loglik <- rel.diff(Theta.hat.cv.loglik, Theta)
points(log2(out.cv.loglik$Tuning[2]), rmse.cv.loglik, col="purple", pch=19)
plot(log2(lambda.grid), rmse.arr.glasso, type="l",
xlab="log2(lambda)", ylab="RMSE",
xlim = range(log2(lambda.grid)),     # or use c(min, max)
ylim = range(rmse.arr.glasso))
rmse.att.glasso <- rel.diff(Theta.hat.att.glasso, Theta)
abline(h = rmse.att.glasso, col = "blue", lwd = 2, lty = 2)
rmse.huge.stars <- rel.diff(Theta.hat.huge.stars, Theta)
points(log2(out.huge.stars$opt.lambda), rmse.huge.stars, col="red", pch=19)
rmse.huge.ric <- rel.diff(Theta.hat.huge.ric, Theta)
points(log2(out.huge.ric$opt.lambda), rmse.huge.ric, col="green", pch=19)
rmse.huge.ebic <- rel.diff(Theta.hat.huge.ebic, Theta)
points(log2(out.huge.ebic$opt.lambda), rmse.huge.ebic, col="purple", pch=19)
rmse.cv.loglik <- rel.diff(Theta.hat.cv.loglik, Theta)
points(log2(out.cv.loglik$Tuning[2]), rmse.cv.loglik, col="orange", pch=19)
load("~/Downloads/band1_p100_n300_diag0_R20_data.RData")
library(huge)
library(glasso)
library(CVglasso)
library(ATTglasso)
library(corrplot)
# Get ground truth
r <- 1
Theta <- Theta_list[[r]]
X <- X_list[[r]]
out.att.glasso <- glasso_autotune(X=X, alpha=0.02, thr=0.005, maxit=10, penalize_diag=TRUE, verbose=FALSE)
Theta.hat.att.glasso <- out.att.glasso$Theta
pen <- TRUE
out.huge <- huge(X, method = "glasso", verbose=FALSE)
out.huge.ebic <- huge.select(out.huge, criterion = "ebic", verbose=FALSE)
Theta.hat.huge.ebic <- glasso(s=cov(X),rho=out.huge.ebic$opt.lambda, penalize.diagonal=pen)$wi
out.huge <- huge(X, method = "glasso", verbose=FALSE)
out.huge.ric <- huge.select(out.huge, criterion = "ric", verbose=FALSE)
Theta.hat.huge.ric <- glasso(s=cov(X),rho=out.huge.ric$opt.lambda, penalize.diagonal=pen)$wi
out.cv.loglik = CVglasso(X=X, S=cov(X), crit.cv="loglik", K=5, diagonal=pen, trace="none")
Theta.hat.cv.loglik <- glasso(s=cov(X),rho=out.cv.loglik$Tuning[2], penalize.diagonal=pen)$wi
out.huge <- huge(X, method = "glasso", verbose=FALSE)
out.huge.stars <- huge.select(out.huge, criterion = "stars", verbose=FALSE)
Theta.hat.huge.stars <- glasso(s=cov(X),rho=out.huge.stars$opt.lambda, penalize.diagonal=pen)$wi
plot_corr_matrix <- function(Theta, title) {
corrplot::corrplot(
cov2cor(abs(Theta)),
method = "color",
tl.pos = "n",
title = title,
diag = FALSE,
is.corr = FALSE,
col = colorRampPalette(c("white", "black"))(256),
cl.pos = "n",
mar = c(0, 0, 2, 0)
)
}
# pdf(file = paste0("corrplot_AR1.pdf"), width = 8, height = 6)
par(mfrow = c(2, 3), mar = c(1, 1, 3, 1))
plot_corr_matrix(Theta, "Ground truth")
plot_corr_matrix(Theta.hat.att.glasso, "AutotuneGLASSO")
plot_corr_matrix(Theta.hat.huge.ebic, "eBIC")
plot_corr_matrix(Theta.hat.huge.ric, "RIC")
plot_corr_matrix(Theta.hat.huge.stars, "StARS")
plot_corr_matrix(Theta.hat.cv.loglik, "5-fold CV")
par(mfrow = c(1, 1))
# dev.off()
lower = -13
upper = 3
lambda.grid <- 2^seq(upper, lower, by = -0.1); l <- length(lambda.grid)
# source("library_test.R")
library(glasso)
rmse.arr.glasso = bic.arr.glasso = aic.arr.glasso = array(NA, l)
auroc.arr.glasso = array(NA, l)
flag <- 0
for(i in 1:l){
# Estimate
lambda <- lambda.grid[i]
# print(paste("start of", i, "-th exp for", r,"-th rep, ", log2(lambda)))
Theta.hat.glasso <- glasso(s=cov(X),rho=lambda)$wi
if(any(is.na(Theta.hat.glasso))){
rmse.arr.glasso[i] = auroc.arr.glasso[i] = NA
} else {
rmse.arr.glasso[i]<- rel.diff(Theta.hat.glasso, Theta)
}
i.best <- 0
if(i==1){
Theta.hat.best <- Theta.hat.glasso
start.rmse <- rmse.arr.glasso[i]
min.rmse <- NULL
i.best <- i
}
if(!is.na(rmse.arr.glasso[i])){
# now.bic <- bic.arr.glasso[i]
now.rmse <- rmse.arr.glasso[i]
min.rmse <- min(min.rmse, now.rmse)
if(min.rmse >= now.rmse){
i.best <- i
Theta.hat.best <- Theta.hat.glasso
}
if(now.rmse > min.rmse && now.rmse - min.rmse >= 0.4 * (start.rmse - min.rmse))
flag <- 1
}
if(flag == 1)
break
# print(paste("end of", i, "-th exp for", r,"-th rep,", log2(lambda)))
}
temp <- data.frame(rmse.arr.glasso)
plot(log2(lambda.grid), rmse.arr.glasso, type="l",
xlab="log2(lambda)", ylab="RMSE",
xlim = range(log2(lambda.grid)),     # or use c(min, max)
ylim = range(rmse.arr.glasso))
plot(log2(lambda.grid), rmse.arr.glasso, type="l",
xlab="log2(lambda)", ylab="RMSE")
rmse.att.glasso <- rel.diff(Theta.hat.att.glasso, Theta)
abline(h = rmse.att.glasso, col = "blue", lwd = 2, lty = 2)
rmse.huge.stars <- rel.diff(Theta.hat.huge.stars, Theta)
points(log2(out.huge.stars$opt.lambda), rmse.huge.stars, col="red", pch=19)
rmse.huge.ric <- rel.diff(Theta.hat.huge.ric, Theta)
points(log2(out.huge.ric$opt.lambda), rmse.huge.ric, col="green", pch=19)
rmse.huge.ebic <- rel.diff(Theta.hat.huge.ebic, Theta)
points(log2(out.huge.ebic$opt.lambda), rmse.huge.ebic, col="purple", pch=19)
rmse.cv.loglik <- rel.diff(Theta.hat.cv.loglik, Theta)
points(log2(out.cv.loglik$Tuning[2]), rmse.cv.loglik, col="orange", pch=19)
library(huge)
library(glasso)
library(CVglasso)
library(ATTglasso)
library(corrplot)
# Get ground truth
r <- 2
Theta <- Theta_list[[r]]
X <- X_list[[r]]
out.att.glasso <- glasso_autotune(X=X, alpha=0.02, thr=0.005, maxit=10, penalize_diag=TRUE, verbose=FALSE)
Theta.hat.att.glasso <- out.att.glasso$Theta
pen <- TRUE
out.huge <- huge(X, method = "glasso", verbose=FALSE)
out.huge.ebic <- huge.select(out.huge, criterion = "ebic", verbose=FALSE)
Theta.hat.huge.ebic <- glasso(s=cov(X),rho=out.huge.ebic$opt.lambda, penalize.diagonal=pen)$wi
out.huge <- huge(X, method = "glasso", verbose=FALSE)
out.huge.ric <- huge.select(out.huge, criterion = "ric", verbose=FALSE)
Theta.hat.huge.ric <- glasso(s=cov(X),rho=out.huge.ric$opt.lambda, penalize.diagonal=pen)$wi
out.cv.loglik = CVglasso(X=X, S=cov(X), crit.cv="loglik", K=5, diagonal=pen, trace="none")
Theta.hat.cv.loglik <- glasso(s=cov(X),rho=out.cv.loglik$Tuning[2], penalize.diagonal=pen)$wi
out.huge <- huge(X, method = "glasso", verbose=FALSE)
out.huge.stars <- huge.select(out.huge, criterion = "stars", verbose=FALSE)
Theta.hat.huge.stars <- glasso(s=cov(X),rho=out.huge.stars$opt.lambda, penalize.diagonal=pen)$wi
plot_corr_matrix <- function(Theta, title) {
corrplot::corrplot(
cov2cor(abs(Theta)),
method = "color",
tl.pos = "n",
title = title,
diag = FALSE,
is.corr = FALSE,
col = colorRampPalette(c("white", "black"))(256),
cl.pos = "n",
mar = c(0, 0, 2, 0)
)
}
# pdf(file = paste0("corrplot_AR1.pdf"), width = 8, height = 6)
par(mfrow = c(2, 3), mar = c(1, 1, 3, 1))
plot_corr_matrix(Theta, "Ground truth")
plot_corr_matrix(Theta.hat.att.glasso, "AutotuneGLASSO")
plot_corr_matrix(Theta.hat.huge.ebic, "eBIC")
plot_corr_matrix(Theta.hat.huge.ric, "RIC")
plot_corr_matrix(Theta.hat.huge.stars, "StARS")
plot_corr_matrix(Theta.hat.cv.loglik, "5-fold CV")
par(mfrow = c(1, 1))
# dev.off()
lower = -13
upper = 3
lambda.grid <- 2^seq(upper, lower, by = -0.1); l <- length(lambda.grid)
# source("library_test.R")
library(glasso)
rmse.arr.glasso = bic.arr.glasso = aic.arr.glasso = array(NA, l)
auroc.arr.glasso = array(NA, l)
flag <- 0
for(i in 1:l){
# Estimate
lambda <- lambda.grid[i]
# print(paste("start of", i, "-th exp for", r,"-th rep, ", log2(lambda)))
Theta.hat.glasso <- glasso(s=cov(X),rho=lambda)$wi
if(any(is.na(Theta.hat.glasso))){
rmse.arr.glasso[i] = auroc.arr.glasso[i] = NA
} else {
rmse.arr.glasso[i]<- rel.diff(Theta.hat.glasso, Theta)
}
i.best <- 0
if(i==1){
Theta.hat.best <- Theta.hat.glasso
start.rmse <- rmse.arr.glasso[i]
min.rmse <- NULL
i.best <- i
}
if(!is.na(rmse.arr.glasso[i])){
# now.bic <- bic.arr.glasso[i]
now.rmse <- rmse.arr.glasso[i]
min.rmse <- min(min.rmse, now.rmse)
if(min.rmse >= now.rmse){
i.best <- i
Theta.hat.best <- Theta.hat.glasso
}
if(now.rmse > min.rmse && now.rmse - min.rmse >= 0.4 * (start.rmse - min.rmse))
flag <- 1
}
if(flag == 1)
break
# print(paste("end of", i, "-th exp for", r,"-th rep,", log2(lambda)))
}
temp <- data.frame(rmse.arr.glasso)
plot(log2(lambda.grid), rmse.arr.glasso, type="l",
xlab="log2(lambda)", ylab="RMSE")
rmse.att.glasso <- rel.diff(Theta.hat.att.glasso, Theta)
abline(h = rmse.att.glasso, col = "blue", lwd = 2, lty = 2)
rmse.huge.stars <- rel.diff(Theta.hat.huge.stars, Theta)
points(log2(out.huge.stars$opt.lambda), rmse.huge.stars, col="red", pch=19)
rmse.huge.ric <- rel.diff(Theta.hat.huge.ric, Theta)
points(log2(out.huge.ric$opt.lambda), rmse.huge.ric, col="green", pch=19)
rmse.huge.ebic <- rel.diff(Theta.hat.huge.ebic, Theta)
points(log2(out.huge.ebic$opt.lambda), rmse.huge.ebic, col="purple", pch=19)
rmse.cv.loglik <- rel.diff(Theta.hat.cv.loglik, Theta)
points(log2(out.cv.loglik$Tuning[2]), rmse.cv.loglik, col="orange", pch=19)
#### Lab (Week 1) ####
#### Step 1. Create a vector containing the following
# ten values: 4, 7, 2, 8, 5, 9, 3, 6, 1, 10. Assign
# it to a variable called X.
X <- c(4, 7, 2, 8, 5, 9, 3, 6, 1, 10)
#### Step 2. Compute the length of the vector X.
# Assign this value to a variable called n.
n <- length(X)
#### Step 3. Compute the average of the values attached to the
# variable X. Assign this value to a variable called meanX.
meanX <- mean(X)
#### Step 4. Square all of the values in the vector X
# (Raise each value to the power of 2). Assign the
# result to a variable called Squares.
Squares <- X^2
#### Step 5. Look up the sum() function in the Help window
# by searching sum or running the command ?sum.
# Read its description, then use it to
# add together all of the values in the vector Squares.
# Assign the result to a variable called TotalSquares.
TotalSquares <- sum(Squares)
#### Step 6. Square meanX, then multiply it by n. Assign
# the result to a variable called meanXSq.
meanXSq <- (meanX^2) * n
#### Step 7. Subtract meanXSq from TotalSquares, then
# divide the result by n-1. Put one set of parentheses
# around TotalSquares minus meanXSq and another set
# around n-1. Assign the result to a variable called Result1.
Result1 <- (TotalSquares - meanXSq) / (n - 1)
#### Step 8. Result1 will most likely be computed to a large
# number of decimal places. Use the round() function to
# round your result to five decimal places. Then assign this
# result to the variable Result1. This overwrites your
# originally computed value with a rounded version. To use
# the round() function, you’ll need to look it up in the
# Help documentation.
# Since you haven't seen the round() function, we've provided
# code to get you started.
# Fill in the command with the appropriate 'digits = ' argument.
Result1 <- round(Result1, digits = 5)
#### Step 9. var() is a built-in R function that will automatically complete all
# the computations you did in Steps 3-7. Compute var(X). Assign the resulting
# value to a variable called Result2.
Result2 <- var(X)
#### Step 10. Round Result2 to five decimal places, following
# the same steps you followed in Step 8.
Result2 <- round(Result2, digits = 5)
#### Step 11. Use a comparison to determine whether Result1
# is the same as Result2. If all went well above, the comparison
# will result in TRUE.
Result1 == Result2
setwd("~/Documents/Cornell/Projects/FC_SC/Code/Rpack/ATTglasso")
devtools::build()
library(ATTglasso)
#---------- Simulate data ----------#
set.seed(1)
p <- 20
n <- 100
choose(p,2)
data.name <- paste0("band1_p", p, "_n",n)
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:p]) <- offd1
diag(Theta[2:p, 1:(p-1)]) <- offd1
eigen(Theta)$values
Sigma <- solve(Theta)
diag(Sigma)
eigen(Sigma)$values
if (min(eigen(Sigma)$values)<=1e-3) {
stop("Sigma is not positive definite")
}
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
#---------- Load libraries ----------#
library(MASS)
library(corrplot)
n = nrow(X)
p = ncol(X)
S = t(X)%*%X/n
sigma2.hat = diag(S)
W.old = W = S; Theta = array(0, c(p,p))
e.old = 1e6
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
corrplot(cov2cor(Theta), method = "color", tl.pos="n")
n = nrow(X)
p = ncol(X)
S = t(X)%*%X/n
sigma2.hat = diag(S)
W.old = W = S; Theta = array(0, c(p,p))
e.old = 1e6
final.cycle = FALSE
lambda0 <- numeric(p)
lambda <- numeric(p)
iter = 1
j = 1
W.11 = W[-j,-j]
s.12 = S[-j,j]
s.22 = S[j,j]
out <- glasso_autotune(X = X, verbose_i=TRUE)
devtools::build()
devtools::install()
library(ATTglasso)
out <- glasso_autotune(X = X, verbose_i=TRUE)
devtools::build()
devtools::install()
library(ATTglasso)
#---------- Load libraries ----------#
library(MASS)
library(corrplot)
#---------- Simulate data ----------#
set.seed(1)
p <- 20
n <- 100
choose(p,2)
data.name <- paste0("band1_p", p, "_n",n)
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:p]) <- offd1
diag(Theta[2:p, 1:(p-1)]) <- offd1
eigen(Theta)$values
Sigma <- solve(Theta)
diag(Sigma)
eigen(Sigma)$values
if (min(eigen(Sigma)$values)<=1e-3) {
stop("Sigma is not positive definite")
}
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
corrplot(cov2cor(Theta), method = "color", tl.pos="n")
n = nrow(X)
p = ncol(X)
S = t(X)%*%X/n
sigma2.hat = diag(S)
W.old = W = S; Theta = array(0, c(p,p))
e.old = 1e6
final.cycle = FALSE
lambda0 <- numeric(p)
lambda <- numeric(p)
iter = 1
j = 1
W.11 = W[-j,-j]
s.12 = S[-j,j]
s.22 = S[j,j]
out <- glasso_autotune(X = X, verbose_i=TRUE)
out$lambdas
View(round(out$Theta,3))
corrplot(cov2cor(out$Theta), method = "color", tl.pos="n")
library(glasso)
?glasso
?glasso
out.glasso <- glasso(s=S, rho=as.numeric(out$lambdas))
View(out.glasso)
View(round(out.glasso$wi,3))
corrplot(cov2cor(out.glasso$wi), method = "color", tl.pos="n")
rm(list = ls())
setwd("~/Documents/Cornell/Projects/FC_SC/Code/Rpack/ATTglasso")
#---------- Load libraries ----------#
library(MASS)
library(corrplot)
#---------- Simulate data ----------#
set.seed(1)
p <- 20
n <- 100
choose(p,2)
data.name <- paste0("band1_p", p, "_n",n)
Theta <- matrix(data=0, nrow=p, ncol=p)
diag(Theta) <- 1
offd1 <- 0.3
diag(Theta[1:(p-1), 2:p]) <- offd1
diag(Theta[2:p, 1:(p-1)]) <- offd1
eigen(Theta)$values
Sigma <- solve(Theta)
diag(Sigma)
eigen(Sigma)$values
if (min(eigen(Sigma)$values)<=1e-3) {
stop("Sigma is not positive definite")
}
X <- mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
corrplot(cov2cor(Theta), method = "color", tl.pos="n")
#---------- Test ----------#
n = nrow(X)
p = ncol(X)
S = t(X)%*%X/n
sigma2.hat = diag(S)
W.old = W = S; Theta = array(0, c(p,p))
e.old = 1e6
final.cycle = FALSE
lambda0 <- numeric(p)
lambda <- numeric(p)
iter = 1
j = 1
W.11 = W[-j,-j]
s.12 = S[-j,j]
s.22 = S[j,j]
out <- glasso_autotune(X = X, verbose_i=TRUE)
corrplot(cov2cor(out$Theta), method = "color", tl.pos="n")
library(glasso)
out.glasso <- glasso(s=S, rho=as.numeric(out$lambdas))
corrplot(cov2cor(out.glasso$wi), method = "color", tl.pos="n")
par(mfrow = c(1,2))
corrplot(cov2cor(out$Theta), method = "color", tl.pos="n")
corrplot(cov2cor(out.glasso$wi), method = "color", tl.pos="n")
par(mfrow = c(1,1))
cov2cor(out$Theta) == cov2cor(out.glasso$wi)
(abs((out$Theta)) > 0) == ((abs(out.glasso$wi)) > 0)
lower.tri(out$Theta)
lower.tri(out$Theta)
out$Theta[lower.tri(out$Theta)]
out.glasso$wi[lower.tri(out.glasso$wi)]
att <- out$Theta[lower.tri(out$Theta)]
gl <- out.glasso$wi[lower.tri(out.glasso$wi)]
(att != 0) == (gl != 0)
which((att != 0) != (gl != 0))
att[24]
gl[24]
